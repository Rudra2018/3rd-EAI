
from __future__ import annotations
import math
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple

try:
    from sentence_transformers import SentenceTransformer  # type: ignore
    _EMB_OK = True
except Exception:
    SentenceTransformer = None  # type: ignore
    _EMB_OK = False

@dataclass
class Evidence:
    request: Dict[str, Any]
    response: Dict[str, Any]
    snippet: Optional[str] = None

@dataclass
class Finding:
    id: str
    title: str
    severity: str  # info|low|medium|high|critical
    score: float   # 0..1
    category: str  # e.g., auth_bypass, idor, graphql_introspection
    endpoint: str
    evidence: Evidence
    recommendations: List[str] = field(default_factory=list)

class AIVulnerabilityDetector:
    def __init__(self) -> None:
        self.model = None
        if _EMB_OK:
            try:
                self.model = SentenceTransformer("sentence-transformers/all-MiniLM-L6-v2")
            except Exception:
                self.model = None

    @staticmethod
    def _heuristics(sample: Dict[str, Any]) -> List[Tuple[str, float]]:
        req, resp = sample.get("request", {}), sample.get("response", {})
        status = int(resp.get("status", 0) or 0)
        body = (resp.get("body") or "")[:10000]
        url = req.get("url", "")
        method = (req.get("method") or "").upper()

        hits: List[Tuple[str, float]] = []

        if ("/admin" in url or "/me" in url or "/users" in url) and status in (200, 201) and not (req.get("headers", {}) or {}).get("Authorization"):
            hits.append(("auth_bypass", 0.85))

        if any(k in url.lower() for k in ["/user/", "/account/", "/tenant/"]):
            hits.append(("idor", 0.35))

        if "__schema" in body or "GraphQL introspection" in body:
            hits.append(("graphql_introspection", 0.95))

        if any(s in body for s in ["Traceback", "org.springframework", "You have an error in your SQL syntax"]):
            hits.append(("error_leakage", 0.55))

        hdrs = {k.lower(): v for k, v in (resp.get("headers") or {}).items()}
        if hdrs.get("access-control-allow-origin") == "*" and hdrs.get("access-control-allow-credentials") == "true":
            hits.append(("cors_misconfig", 0.7))

        if method in {"POST","PUT","PATCH"} and (hdrs.get("content-type","").startswith("text/html")):
            hits.append(("content_type_anomaly", 0.35))

        return hits

    def _semantic_score(self, text: str) -> float:
        if not self.model:
            return 0.0
        v = self.model.encode([text])[0]
        try:
            norm = float((v**2).sum())
        except Exception:
            norm = 0.0
        import math
        return 1 - math.exp(-min(norm, 2000.0)/2000.0)

    def analyze(self, sample: Dict[str, Any]) -> List[Finding]:
        url = sample.get("request", {}).get("url", "")
        ev = Evidence(request=sample.get("request", {}), response=sample.get("response", {}))

        heur = self._heuristics(sample)
        findings: List[Finding] = []

        for cat, weight in heur:
            sev = "info"
            if weight >= 0.9: sev = "critical"
            elif weight >= 0.7: sev = "high"
            elif weight >= 0.5: sev = "medium"
            elif weight >= 0.3: sev = "low"

            score = weight
            body = sample.get("response", {}).get("body", "")
            score = min(1.0, score * (0.9 + 0.2 * self._semantic_score(body)))

            recs = {
                "auth_bypass": ["Enforce auth middleware on sensitive routes.", "Add tests for 401/403 unauthenticated."],
                "idor": ["Perform object-level checks using owner/tenant IDs.", "Adopt ABAC/RBAC consistently."],
                "graphql_introspection": ["Disable introspection in production.", "Gate behind admin tokens."],
                "error_leakage": ["Return generic errors; log stack traces.", "Disable debug in prod."],
                "cors_misconfig": ["Do not use ACAO=* with credentials.", "Use explicit origin allowlist."],
                "content_type_anomaly": ["Validate Content-Type strictly.", "Whitelist upload MIME types."],
            }.get(cat, [])

            findings.append(Finding(
                id=f"{cat}:{abs(hash(url))%10_000}",
                title=cat.replace('_',' ').title(),
                severity=sev,
                score=round(score, 3),
                category=cat,
                endpoint=url,
                evidence=ev,
                recommendations=recs,
            ))

        return findings
